package liquibase.migrator.change;

import liquibase.database.Database;
import liquibase.migrator.Migrator;
import liquibase.migrator.RollbackImpossibleException;
import liquibase.migrator.UnsupportedChangeException;
import liquibase.util.MD5Util;
import liquibase.util.StreamUtil;
import liquibase.util.StringUtils;
import liquibase.util.XMLUtil;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.IOException;
import java.io.Writer;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.*;
import java.util.logging.Logger;

/**
 * Standard superclass for Changes to implement.
 *
 * @see liquibase.migrator.change.Change
 */
public abstract class AbstractChange implements Change {

    private String changeName;
    private String tagName;

    protected AbstractChange(String tagName, String changeName) {
        this.tagName = tagName;
        this.changeName = changeName;
    }

    public String getChangeName() {
        return changeName;
    }

    public String getTagName() {
        return tagName;
    }

    /**
     * Executes the statements in this change against the passed database
     */
    public void executeStatements(Database database) throws SQLException, UnsupportedChangeException {
        String[] statements = generateStatements(database);

        execute(statements, database);
    }

    /**
     * Outputs the SQL statements generated by this change.
     */
    public void saveStatements(Database database, Writer writer) throws IOException, UnsupportedChangeException {
        String[] statements = generateStatements(database);
        for (String statement : statements) {
            writer.append(statement + ";" + StreamUtil.getLineSeparator() + StreamUtil.getLineSeparator());
        }
    }


    private void execute(String[] statements, Database database) throws SQLException {
        for (String statement : statements) {
            Logger.getLogger(Migrator.DEFAULT_LOG_NAME).finest("Executing Statement: " + statement);
            try {
                Statement dbStatement = database.getConnection().createStatement();
                dbStatement.execute(statement);
                dbStatement.close();
            } catch (SQLException e) {
                throw new SQLException((e.getMessage() + " [" + statement + "]").replaceAll("\n", "").replaceAll("\r", ""));
            }
        }
    }

    /**
     * Rolls back the statements in this change against the passed database
     */
    public void executeRollbackStatements(Database database) throws SQLException, UnsupportedChangeException, RollbackImpossibleException {
        String[] statements = generateRollbackStatements(database);
        execute(statements, database);
    }

    /**
     * Outputs the statements nessisary to roll back this change.
     */
    public void saveRollbackStatement(Database database, Writer writer) throws IOException, UnsupportedChangeException, RollbackImpossibleException {
        String[] statements = generateRollbackStatements(database);
        for (String statement : statements) {
            writer.append(statement + ";\n\n");
        }
    }

    public String[] generateRollbackStatements(Database database) throws UnsupportedChangeException, RollbackImpossibleException {
        return generateRollbackStatementsFromInverse(database);
    }

    /**
     * Generates rollback statements from the inverse changes returned by createInverses().
     */
    private String[] generateRollbackStatementsFromInverse(Database database) throws UnsupportedChangeException, RollbackImpossibleException {
        Change[] inverses = createInverses();
        if (inverses == null) {
            throw new RollbackImpossibleException("No inverse to " + getClass().getName() + " created");
        }

        List<String> statements = new ArrayList<String>();

        for (Change inverse : inverses) {
            statements.addAll(Arrays.asList(inverse.generateStatements(database)));
        }

        return statements.toArray(new String[statements.size()]);
    }

    /**
     * Can this change be rolled back.
     */
    public boolean canRollBack() {
        return createInverses() != null;
    }

    /**
     * Create inverse changes that can roll back this change.
     */
    protected Change[] createInverses() {
        return null;
    }

    public String getMD5Sum() {
        try {
            StringBuffer buffer = new StringBuffer();
            nodeToStringBuffer(createNode(DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument()), buffer);
            return MD5Util.computeMD5(buffer.toString());
        } catch (ParserConfigurationException e) {
            throw new RuntimeException(e);
        }
    }

    private void nodeToStringBuffer(Element node, StringBuffer buffer) {
        buffer.append("<").append(node.getNodeName());
        SortedMap<String, String> attributeMap = new TreeMap<String, String>();
        NamedNodeMap attributes = node.getAttributes();
        for (int i = 0; i < attributes.getLength(); i++) {
            Node attribute = attributes.item(i);
            attributeMap.put(attribute.getNodeName(), attribute.getNodeValue());
        }
        for (Map.Entry entry : attributeMap.entrySet()) {
            Object value = entry.getValue();
            if (value != null) {
                buffer.append(" ").append(entry.getKey()).append("=\"").append(attributeMap.get(value)).append("\"");
            }
        }
        buffer.append(">").append(StringUtils.trimToEmpty(XMLUtil.getTextContent(node)));
        NodeList childNodes = node.getChildNodes();
        for (int i = 0; i < childNodes.getLength(); i++) {
            Node childNode = childNodes.item(i);
            if (childNode instanceof Element) {
                nodeToStringBuffer(((Element) childNode), buffer);
            }
        }
        buffer.append("</").append(node.getNodeName()).append(">");
    }
}
