<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
    <head>
        <title>LiquiBase: ChangeSet</title>
        <style type='text/css' media='screen'>@import "../../include/css/main.css";</style>
    </head>
    <body>@ANALYTICS@
        <img src="../../images/liquibase_logo.gif" alt="LiquiBase" class="topLogo"/>
        <p id="sitename">
            <strong>LiquiBase: Database Refactoring</strong>
        </p>

        <div id="container">
                @NAV.MANUAL@


            <div id="content">
                <div class="entry">
                    <h2>&lt;changeSet&gt; tag</h2>
                    <p>
                        The changeSet tag is what you use to group database refactorings together.
                    </p>
                    <pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;databaseChangeLog
  xmlns="http://www.liquibase.org/xml/ns/dbchangelog/1.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog/1.0
         http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-1.0.xsd"&gt;
    &lt;changeSet id="1" author="bob"&gt;
        &lt;comment&gt;A sample change log&lt;/comment&gt;
        &lt;createTable/&gt;
    &lt;/changeSet&gt;
    &lt;changeSet id="2" author="bob" alwaysRun="true"&gt;
        &lt;alterTable/&gt;
    &lt;/changeSet&gt;
    &lt;changeSet id="1" author="alice" failOnError="false"&gt;
        &lt;alterTable/&gt;
    &lt;/changeSet&gt;
&lt;/databaseChangeLog&gt;
                    </pre>
                    <p>
                        Each changeSet tag is uniquely identified by the combination of the "id" tag, the "author" tag,
                        and the changelog file classpath name.  The id tag is only used as an identifier, it does not direct the
                        order that changes are run and does not even have to be an integer.
                    </p>
                    <p>
                        As LiquiBase executes the databaseChangeLog, it reads the changeSets in order and, for each one,
                        checks the "databasechangelog" table to see if the combination of id/author/filename has been run.
                        If it has been run, the changeSet will be skipped unless there is a true "alwaysRun" tag.
                        After all the refactorings in the changeSet are run, LiquiBase will insert a new row with the id/author/filename
                        along with an MD5Sum of the changeSet (see below) in the "databasechangelog".
                    </p>
                    <p>
                        LiquiBase attempts to execute each changeSet in a transaction that is committed at the end, or rolled back if there is an error.
                        Some databases will auto-commit statements which interferes with this transaction setup and could lead to an unexpected
                        database state.  Therefore, it is usually best to have just one refactoring per changeSet unless there is a group of non-auto-committing
                        changes that you want applied as a transaction such as inserting data.
                    </p>
                    <h3>Comments</h3>
                    <p>
                        If you want or need to add comments to a particular change set, the best way is to use the &lt;comment&gt; tag.
                        While XML comments will provide the same benefit, future releases of LiquiBase may be able to make use of &lt;comment&gt; tag comments
                        to generate documentation. 
                    </p>
                    <h3>ChangeSet MD5 Sums</h3>
                    <p>
                        When LiquiBase reaches a changeSet, it computes an MD5Sum it and stores this MD5Sum in the "databasechangelog".
                        The value of storing the MD5Sum is so that LiquiBase can know if someone changed the refactorings in the changeSet since it was ran.
                        If the changeSet was changed since it was ran, LiquiBase will exit the migration with an error because it cannot know what was changed
                        and the database may be in a state different than what the changeLog is expecting.  If there was a valid reason for the changeSet to have
                        been changed and you want to ignore this error, update the databasechangelog table so that the row with the corresponding id/author/filename
                        as a null value for the MD5Sum.  The next time LiquiBase runs, it will update the MD5Sum value to the new correct value.
                    </p>
                    <p>
                        MD5Sums are also used in conjunction with the "runOnChange" changeSet attribute.  There are times you may not want to add a new
                        changeSet because you only need to know about the current version, but you want this change applied whenever it is update.
                        A good example of when you would want this is stored procedures.  If you copy the entire text of the stored procedure to a new changeSet each time you
                        make a change you will not only end up with a very long changeLog, but you will loose the merging and diff-ing power of your source control.
                        Instead, put the text of the stored procedure in a changeSet with a runOnChange="true" attribute.  The stored procedure will only be re-created when and only when
                        there is a change to the text of it.  
                    </p>
                </div>
            </div>
        </div>

    </body>
</html>